## 排序算法总结（内部排序）

插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序


|排序法| 平均时间 | 最差情形 | 稳定度 | 额外空间 |备注                       |
|:---  |  :---  |  :---    | :---  |  :---    |:---                       |
|插入  | O(n2)   |	 O(n2) |	稳定	 |O(1)	  |大部分已排序时较好           |
|希尔  |O(nlogn) |	O(ns) ,1<s<2|	不稳定|O(1) |s是所选分组                 |
|选择  | O(n2)	 | O(n2)   |	不稳定	|O(1)	   |n小时较好                   |
|堆    |	O(nlogn)|	O(nlogn)|不稳定	 |O(1)    |n大时较好                   |
|冒泡  |  O(n^2) |  O(n^2) |稳定     | O(1)   |n小时较好                   |
|快速	 |O(nlogn) |	O(n2)	 |不稳定   |O(nlogn)|n大时较好                   |
|归并	 |O(nlogn) |O(nlogn) |稳定     |	O(1)	|n大时较好                   |
|基数  |O(logRB) |O(logRB) |稳定	   |O(n)	  |B是真数(0-9)，R是基数(个十百)|
|交换	 |O(n2)    |O(n2) 	 |不稳定	  |O(1)    |	n小时较好                 |


### 直接插入排序
```
'''
插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。
例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；
第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；
第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中......
第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。
思想：
进行n-1次排序，第i次排序，将第i+1个数分别与前i个数据比较，找到合适的位置。
找法为：l[i+1]与l[i]比较，排序，跟踪l[i+1]的位置。
'''
直接插入排序是稳定的。算法时间复杂度是O(n^2)
def insertSort(l):
    n = len(l)
    for i in range(1,n):
        for j in range(i-1,-1,-1):
            if l[i] >= l[j]:
                break
            elif l[i] < l[j]:
                l[i],l[j]=l[j],l[i]
                i = j
    return l
l = [45, 32, 8, 33, 12, 22, 19, 97]
insertSort(l)
```

### 希尔（shell）排序

```
先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。
先在各组内进行直接插入排序；
然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量,即所有记录放在同一组中进行直接插入排序为止。
# -*- coding:utf-8 -*-
def shell_sort(l):
    n=len(l)
    gap=n//2
    while gap>0:
        for i in range(gap,n):
            temp=l[i]
            j=i - gap
            while j>=0 and temp<l[j]:
                l[j+gap]=l[j]
                j-=gap
            l[j+gap]=temp
        gap//=2
    return l

#测试
l=[10,23,1,53,654,54,16,646,65,3155,546,31]
shell_sort(l)
```
